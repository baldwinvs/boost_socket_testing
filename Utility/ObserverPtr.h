#ifndef UTILITY_OBSERVERPTR_H
#define UTILITY_OBSERVERPTR_H

/*
 * This file was originally generated by ChatGPT on 8 April, 2025.
 */

#include <cstddef> // for std::nullptr_t
#include <type_traits>

//
// Policy selector for const vs non-const data access
//
template <typename T, bool IsConst> struct DataTypeSelector;

template <typename T> struct DataTypeSelector<T, false>
{
    using Pointer = T *;
    using Reference = T &;
};

template <typename T> struct DataTypeSelector<T, true>
{
    using Pointer = const T *;
    using Reference = const T &;
};

//
// Policy selector for whether the pointer itself is fixed or reassignable
//
template <typename PointerType, bool IsFixed> struct PointerStorage;

template <typename PointerType> struct PointerStorage<PointerType, true>
{
  protected:
    PointerStorage(PointerType ptr) : ptr_(ptr) {}
    PointerType const ptr_;
};

template <typename PointerType> struct PointerStorage<PointerType, false>
{
  protected:
    PointerStorage(PointerType ptr) : ptr_(ptr) {}
    PointerType ptr_;
};

//
// Main base class: combines data constness + pointer fixity
//
template <typename T, bool IsDataConst, bool IsPointerFixed>
class ObserverPtrBase : private PointerStorage<typename DataTypeSelector<T, IsDataConst>::Pointer, IsPointerFixed>
{
    using DataTraits = DataTypeSelector<T, IsDataConst>;
    using Pointer = typename DataTraits::Pointer;
    using Reference = typename DataTraits::Reference;

    using Storage = PointerStorage<Pointer, IsPointerFixed>;

  public:
    // Default constructor (null pointer)
    ObserverPtrBase() : Storage(nullptr) {}

    // Constructor from pointer
    explicit ObserverPtrBase(Pointer ptr) : Storage(ptr) {}

    // Copy constructor
    ObserverPtrBase(const ObserverPtrBase &) = default;

    // Assignment operator (enabled if pointer is mutable)
    ObserverPtrBase& operator=(const ObserverPtrBase& other) {
        if (this != &other) {
            this->ptr_ = other.ptr_;
        }
        return *this;
    }

    // Accessors
    Pointer get() const { return this->ptr_; }
    Reference operator*() const { return *this->ptr_; }
    Pointer operator->() const { return this->ptr_; }

    // Null check
    explicit operator bool() const { return this->ptr_ != nullptr; }

    // Comparisons
    friend bool operator==(const ObserverPtrBase &lhs, const ObserverPtrBase &rhs) { return lhs.ptr_ == rhs.ptr_; }
    friend bool operator!=(const ObserverPtrBase &lhs, const ObserverPtrBase &rhs) { return !(lhs == rhs); }
    friend bool operator<(const ObserverPtrBase &lhs, const ObserverPtrBase &rhs) { return lhs.ptr_ < rhs.ptr_; }
    friend bool operator>(const ObserverPtrBase &lhs, const ObserverPtrBase &rhs) { return rhs < lhs; }
    friend bool operator<=(const ObserverPtrBase &lhs, const ObserverPtrBase &rhs) { return !(rhs < lhs); }
    friend bool operator>=(const ObserverPtrBase &lhs, const ObserverPtrBase &rhs) { return !(lhs < rhs); }

  protected:
    using Storage::ptr_; // expose internally if needed
};

//
// Public aliases
//

// Mutable pointer, mutable data
template <typename T> using MutableObserverPtr = ObserverPtrBase<T, false, false>;

// Fixed pointer, mutable data
template <typename T> using FixedObserverPtr = ObserverPtrBase<T, false, true>;

// Fixed pointer, const data
template <typename T> using ImmutableObserverPtr = ObserverPtrBase<T, true, true>;

#endif // UTILITY_OBSERVERPTR_H